{
  "idea": "action-economy-history",
  "status": "issues_created",
  "summary": "Track what actions were taken during a turn, not just how many remain",
  "trigger": "Step of Wind allows Disengage OR Dash - later logic (AoO checks) needs to know which was chosen",
  "phases": {
    "brainstorm": {
      "status": "completed",
      "date": "2024-12-06",
      "file": "brainstorm.md",
      "notes": "Established core design: extend ActionEconomy with history, ActionType in core, ActionRecord with core.Ref source"
    },
    "use_cases": {
      "status": "completed",
      "date": "2024-12-06",
      "file": "use-cases.md",
      "notes": "End-to-end flows revealed proto changes, feature choice interface, and event consolidation needs. Identified condition approach for downstream effects."
    },
    "architecture": {
      "status": "skipped",
      "reason": "Extends existing ActionEconomy pattern in rulebooks/dnd5e/combat, no new architectural decisions needed"
    },
    "design": {
      "status": "completed",
      "date": "2024-12-06",
      "files": ["design-protos.md", "design-toolkit.md", "design-api.md"],
      "notes": "Three design docs covering proto changes, toolkit implementation, and game server integration"
    },
    "issues": {
      "status": "completed",
      "date": "2025-12-06",
      "links": [
        "https://github.com/KirkDiggler/rpg-api-protos/issues/81",
        "https://github.com/KirkDiggler/rpg-toolkit/issues/399",
        "https://github.com/KirkDiggler/rpg-api/issues/266"
      ]
    }
  },
  "decisions": [
    {
      "question": "Where does ActionType live?",
      "answer": "Type in core/combat, constants in rulebooks/dnd5e/combat",
      "reason": "Follows established pattern - core defines types, rulebooks define constants"
    },
    {
      "question": "Where does history live?",
      "answer": "On ActionEconomy itself",
      "reason": "Budget and history go together naturally. TurnContext is a higher layer orchestrating multiple characters' economies"
    },
    {
      "question": "Source field type in ActionRecord?",
      "answer": "core.Ref",
      "reason": "Typed, validated, consistent with rest of system - not a string with typo risk"
    },
    {
      "question": "Keep old UseAction/UseBonusAction methods?",
      "answer": "Remove them, only UseActionFor/UseBonusActionFor",
      "reason": "Pre-release, no backwards compatibility needed. Forces all callers to record what they're using actions for"
    },
    {
      "question": "ActionEconomy pointer or value in FeatureInput?",
      "answer": "Pointer",
      "reason": "Allows distinguishing 'not provided' from 'provided but empty'. Zero-value ActionEconomy gives misleading errors"
    },
    {
      "question": "How does a feature declare its choices?",
      "answer": "Feature interface gains GetActivationChoices() method",
      "reason": "Features self-describe. Game server calls method, empty slice means no choices needed. Connects to existing choice system."
    },
    {
      "question": "How does game server know which features require choices?",
      "answer": "Call GetActivationChoices() - returns empty slice if none needed",
      "reason": "No separate flag needed, the method itself is the check"
    },
    {
      "question": "Who validates ActionType input?",
      "answer": "Feature validates its own requirements",
      "reason": "Same pattern as resource validation. Feature knows what it accepts."
    },
    {
      "question": "Per-feature event topics?",
      "answer": "No - one FeatureActivatedTopic for all features",
      "reason": "Doesn't scale. Homebrew/external modules can't add topics. Subscribers filter by FeatureRef if needed."
    },
    {
      "question": "ActionType string or enum?",
      "answer": "Enum in protos and toolkit",
      "reason": "Type safety, no typos, UI gets exactly the valid options"
    },
    {
      "question": "Query ActionEconomy vs Turn-scoped Conditions for downstream effects?",
      "answer": "Turn-scoped conditions for effects like Disengage (cancels AoO)",
      "reason": "Fits event-driven architecture. Conditions subscribe to events and cancel them. Less coupling than direct queries. Dash speed bonus can still use query since it's a simple calculation."
    }
  ],
  "open_questions": [
    {
      "question": "Should ActionRecord include sequence/timestamp?",
      "options": [
        "Yes - for ordering when it matters",
        "No - turn is atomic, order doesn't matter"
      ],
      "status": "open"
    }
  ],
  "affected_projects": [
    {
      "project": "rpg-api-protos",
      "changes": [
        "ActionType enum in enums.proto",
        "New activation.proto with ActivationChoice/ActivationOption",
        "ActivateFeatureRequest.action_type field",
        "TurnState with action history (ActionRecord)",
        "Breaking: TurnState bools replaced with counts"
      ],
      "design": "design-protos.md"
    },
    {
      "project": "rpg-toolkit",
      "changes": [
        "ActionType type in core/combat",
        "ActionType constants in rulebooks/dnd5e/combat",
        "ActionRecord struct",
        "ActionEconomy with history",
        "ActivationChoiceProvider interface",
        "FeatureInput.ActionType field",
        "FeatureActivatedTopic (replaces per-feature topics)",
        "OpportunityAttackCheckTopic",
        "Disengaged condition (turn-scoped)"
      ],
      "design": "design-toolkit.md"
    },
    {
      "project": "rpg-api",
      "changes": [
        "GetCharacter includes activation choices",
        "ActivateFeature passes ActionType through",
        "ActionType conversion helpers",
        "TurnState â†” ActionEconomy conversion",
        "Movement publishes AoO check events"
      ],
      "design": "design-api.md"
    }
  ]
}
