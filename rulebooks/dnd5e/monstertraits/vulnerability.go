// Copyright (C) 2024 Kirk Diggler
// SPDX-License-Identifier: GPL-3.0-or-later

//nolint:dupl // Vulnerability and Immunity implement same interface with similar structure but different behavior
package monstertraits

import (
	"context"
	"encoding/json"

	"github.com/KirkDiggler/rpg-toolkit/core"
	"github.com/KirkDiggler/rpg-toolkit/core/chain"
	"github.com/KirkDiggler/rpg-toolkit/events"
	"github.com/KirkDiggler/rpg-toolkit/rpgerr"
	"github.com/KirkDiggler/rpg-toolkit/rulebooks/dnd5e/combat"
	"github.com/KirkDiggler/rpg-toolkit/rulebooks/dnd5e/damage"
	dnd5eEvents "github.com/KirkDiggler/rpg-toolkit/rulebooks/dnd5e/events"
	"github.com/KirkDiggler/rpg-toolkit/rulebooks/dnd5e/refs"
)

// VulnerabilityData is the JSON structure for persisting vulnerability trait state
type VulnerabilityData struct {
	Ref        *core.Ref   `json:"ref"`
	OwnerID    string      `json:"owner_id"`
	DamageType damage.Type `json:"damage_type"`
}

// vulnerabilityCondition represents a monster's vulnerability to a specific damage type.
// It implements the ConditionBehavior interface.
type vulnerabilityCondition struct {
	ownerID    string
	damageType damage.Type
	bus        events.EventBus
	subID      string
}

// Ensure vulnerabilityCondition implements dnd5eEvents.ConditionBehavior
var _ dnd5eEvents.ConditionBehavior = (*vulnerabilityCondition)(nil)

// Vulnerability creates a new vulnerability trait that doubles damage of the specified type
func Vulnerability(ownerID string, damageType damage.Type) dnd5eEvents.ConditionBehavior {
	return &vulnerabilityCondition{
		ownerID:    ownerID,
		damageType: damageType,
	}
}

// VulnerabilityJSON creates the JSON representation of a vulnerability trait.
// This is used by factory functions to add trait data before a bus is available.
func VulnerabilityJSON(ownerID string, damageType damage.Type) (json.RawMessage, error) {
	data := VulnerabilityData{
		Ref:        refs.MonsterTraits.Vulnerability(),
		OwnerID:    ownerID,
		DamageType: damageType,
	}
	return json.Marshal(data)
}

// MustVulnerabilityJSON creates the JSON representation of a vulnerability trait.
// It panics if JSON marshaling fails (which should never happen with valid inputs).
// Use this in factory functions where errors indicate programming bugs, not runtime issues.
func MustVulnerabilityJSON(ownerID string, damageType damage.Type) json.RawMessage {
	data, err := VulnerabilityJSON(ownerID, damageType)
	if err != nil {
		panic("monstertraits: failed to marshal vulnerability JSON: " + err.Error())
	}
	return data
}

// IsApplied returns true if this condition is currently applied
func (v *vulnerabilityCondition) IsApplied() bool {
	return v.bus != nil
}

// Apply subscribes this condition to relevant combat events
func (v *vulnerabilityCondition) Apply(ctx context.Context, bus events.EventBus) error {
	if v.IsApplied() {
		return rpgerr.New(rpgerr.CodeAlreadyExists, "vulnerability condition already applied")
	}
	v.bus = bus

	// Subscribe to damage chain to double vulnerable damage
	damageChain := dnd5eEvents.DamageChain.On(bus)
	subID, err := damageChain.SubscribeWithChain(ctx, v.onDamageChain)
	if err != nil {
		return err
	}
	v.subID = subID

	return nil
}

// Remove unsubscribes this condition from events
func (v *vulnerabilityCondition) Remove(ctx context.Context, bus events.EventBus) error {
	if v.bus == nil {
		return nil // Not applied, nothing to remove
	}

	if v.subID != "" {
		err := bus.Unsubscribe(ctx, v.subID)
		if err != nil {
			return err
		}
	}

	v.subID = ""
	v.bus = nil
	return nil
}

// ToJSON converts the condition to JSON for persistence
func (v *vulnerabilityCondition) ToJSON() (json.RawMessage, error) {
	data := VulnerabilityData{
		Ref:        refs.MonsterTraits.Vulnerability(),
		OwnerID:    v.ownerID,
		DamageType: v.damageType,
	}
	return json.Marshal(data)
}

// loadJSON loads vulnerability condition state from JSON
func (v *vulnerabilityCondition) loadJSON(data json.RawMessage) error {
	var vulnerabilityData VulnerabilityData
	if err := json.Unmarshal(data, &vulnerabilityData); err != nil {
		return rpgerr.Wrap(err, "failed to unmarshal vulnerability data")
	}

	v.ownerID = vulnerabilityData.OwnerID
	v.damageType = vulnerabilityData.DamageType

	return nil
}

// onDamageChain adds a vulnerability multiplier component if damage type matches
func (v *vulnerabilityCondition) onDamageChain(
	_ context.Context,
	event *dnd5eEvents.DamageChainEvent,
	c chain.Chain[*dnd5eEvents.DamageChainEvent],
) (chain.Chain[*dnd5eEvents.DamageChainEvent], error) {
	// Only process if we're the target
	if event.TargetID != v.ownerID {
		return c, nil
	}

	// Check if any component has our vulnerable damage type
	hasVulnerableDamage := false
	for idx := range event.Components {
		if event.Components[idx].DamageType == v.damageType {
			hasVulnerableDamage = true
			break
		}
	}

	if !hasVulnerableDamage {
		return c, nil
	}

	// Add vulnerability multiplier component
	addMultiplier := func(_ context.Context, e *dnd5eEvents.DamageChainEvent) (*dnd5eEvents.DamageChainEvent, error) {
		e.Components = append(e.Components, dnd5eEvents.DamageComponent{
			Source:     dnd5eEvents.DamageSourceMonsterTrait,
			SourceRef:  refs.MonsterTraits.Vulnerability(),
			DamageType: v.damageType,
			Multiplier: 2.0,
		})
		return e, nil
	}

	// Add to chain - process in final stage (for resistance/vulnerability/immunity)
	err := c.Add(combat.StageFinal, "vulnerability", addMultiplier)
	if err != nil {
		return c, rpgerr.Wrapf(err, "error applying vulnerability for owner %s", v.ownerID)
	}

	return c, nil
}
