// Copyright (C) 2024 Kirk Diggler
// SPDX-License-Identifier: GPL-3.0-or-later

//nolint:dupl // Trait tests follow same event-driven pattern with different conditions
package monstertraits

import (
	"context"
	"testing"

	"github.com/KirkDiggler/rpg-toolkit/events"
	"github.com/KirkDiggler/rpg-toolkit/rulebooks/dnd5e/combat"
	"github.com/KirkDiggler/rpg-toolkit/rulebooks/dnd5e/damage"
	dnd5eEvents "github.com/KirkDiggler/rpg-toolkit/rulebooks/dnd5e/events"
	"github.com/stretchr/testify/suite"
)

type VulnerabilityTestSuite struct {
	suite.Suite
	bus           events.EventBus
	ctx           context.Context
	vulnerability *vulnerabilityCondition
}

func TestVulnerabilityTestSuite(t *testing.T) {
	suite.Run(t, new(VulnerabilityTestSuite))
}

func (s *VulnerabilityTestSuite) SetupTest() {
	s.bus = events.NewEventBus()
	s.ctx = context.Background()
	s.vulnerability = nil // Will be created in each test
}

func (s *VulnerabilityTestSuite) TestVulnerabilityAddsMultiplierComponent() {
	// Create vulnerability to bludgeoning (skeletons)
	s.vulnerability = Vulnerability("monster-1", damage.Bludgeoning).(*vulnerabilityCondition)

	// Apply to bus
	err := s.vulnerability.Apply(s.ctx, s.bus)
	s.Require().NoError(err)

	// Create damage event with bludgeoning damage
	event := &dnd5eEvents.DamageChainEvent{
		AttackerID: "pc-1",
		TargetID:   "monster-1",
		Components: []dnd5eEvents.DamageComponent{
			{
				Source:         dnd5eEvents.DamageSourceWeapon,
				FinalDiceRolls: []int{3, 4}, // 7 damage
				FlatBonus:      2,           // Total: 9 bludgeoning damage
				DamageType:     damage.Bludgeoning,
			},
		},
		DamageType: damage.Bludgeoning,
	}

	// Publish damage chain event
	chain := events.NewStagedChain[*dnd5eEvents.DamageChainEvent](combat.ModifierStages)
	damageTopic := dnd5eEvents.DamageChain.On(s.bus)

	modifiedChain, err := damageTopic.PublishWithChain(s.ctx, event, chain)
	s.Require().NoError(err)

	// Execute chain to get modified event
	result, err := modifiedChain.Execute(s.ctx, event)
	s.Require().NoError(err)

	// Verify original component unchanged + multiplier component added
	s.Require().Len(result.Components, 2)

	// First component: original damage unchanged
	s.Assert().Equal(9, result.Components[0].Total())
	s.Assert().Equal([]int{3, 4}, result.Components[0].FinalDiceRolls)
	s.Assert().Equal(2, result.Components[0].FlatBonus)

	// Second component: vulnerability multiplier
	s.Assert().Equal(dnd5eEvents.DamageSourceMonsterTrait, result.Components[1].Source)
	s.Assert().Equal(damage.Bludgeoning, result.Components[1].DamageType)
	s.Assert().Equal(2.0, result.Components[1].Multiplier)
}

func (s *VulnerabilityTestSuite) TestVulnerabilityDoesNotAffectOtherDamageTypes() {
	// Create vulnerability to bludgeoning
	s.vulnerability = Vulnerability("monster-1", damage.Bludgeoning).(*vulnerabilityCondition)

	// Apply to bus
	err := s.vulnerability.Apply(s.ctx, s.bus)
	s.Require().NoError(err)

	// Create damage event with slashing damage (not vulnerable)
	event := &dnd5eEvents.DamageChainEvent{
		AttackerID: "pc-1",
		TargetID:   "monster-1",
		Components: []dnd5eEvents.DamageComponent{
			{
				Source:         dnd5eEvents.DamageSourceWeapon,
				FinalDiceRolls: []int{3, 4}, // 7 damage
				FlatBonus:      2,           // Total: 9 slashing damage
				DamageType:     damage.Slashing,
			},
		},
		DamageType: damage.Slashing,
	}

	// Publish damage chain event
	chain := events.NewStagedChain[*dnd5eEvents.DamageChainEvent](combat.ModifierStages)
	damageTopic := dnd5eEvents.DamageChain.On(s.bus)

	modifiedChain, err := damageTopic.PublishWithChain(s.ctx, event, chain)
	s.Require().NoError(err)

	// Execute chain to get modified event
	result, err := modifiedChain.Execute(s.ctx, event)
	s.Require().NoError(err)

	// Verify no multiplier component was added (only original component)
	s.Require().Len(result.Components, 1)
	s.Assert().Equal(9, result.Components[0].Total())
	s.Assert().Equal(dnd5eEvents.DamageSourceWeapon, result.Components[0].Source)
}

func (s *VulnerabilityTestSuite) TestVulnerabilityIgnoresOtherTargets() {
	// Create vulnerability to bludgeoning for monster-1
	s.vulnerability = Vulnerability("monster-1", damage.Bludgeoning).(*vulnerabilityCondition)

	// Apply to bus
	err := s.vulnerability.Apply(s.ctx, s.bus)
	s.Require().NoError(err)

	// Create damage event targeting different monster
	event := &dnd5eEvents.DamageChainEvent{
		AttackerID: "pc-1",
		TargetID:   "monster-2", // Different target
		Components: []dnd5eEvents.DamageComponent{
			{
				Source:         dnd5eEvents.DamageSourceWeapon,
				FinalDiceRolls: []int{3, 4}, // 7 damage
				FlatBonus:      2,           // Total: 9 bludgeoning damage
				DamageType:     damage.Bludgeoning,
			},
		},
		DamageType: damage.Bludgeoning,
	}

	// Publish damage chain event
	chain := events.NewStagedChain[*dnd5eEvents.DamageChainEvent](combat.ModifierStages)
	damageTopic := dnd5eEvents.DamageChain.On(s.bus)

	modifiedChain, err := damageTopic.PublishWithChain(s.ctx, event, chain)
	s.Require().NoError(err)

	// Execute chain to get modified event
	result, err := modifiedChain.Execute(s.ctx, event)
	s.Require().NoError(err)

	// Verify no multiplier component was added (wrong target)
	s.Require().Len(result.Components, 1)
	s.Assert().Equal(9, result.Components[0].Total())
	s.Assert().Equal(dnd5eEvents.DamageSourceWeapon, result.Components[0].Source)
}

func (s *VulnerabilityTestSuite) TestVulnerabilityCanBeRemoved() {
	// Create and apply vulnerability
	s.vulnerability = Vulnerability("monster-1", damage.Bludgeoning).(*vulnerabilityCondition)
	err := s.vulnerability.Apply(s.ctx, s.bus)
	s.Require().NoError(err)
	s.Assert().True(s.vulnerability.IsApplied())

	// Remove vulnerability
	err = s.vulnerability.Remove(s.ctx, s.bus)
	s.Require().NoError(err)
	s.Assert().False(s.vulnerability.IsApplied())
}
