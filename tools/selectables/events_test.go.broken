package selectables

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/suite"

	"github.com/KirkDiggler/rpg-toolkit/dice"
	"github.com/KirkDiggler/rpg-toolkit/events"
)

type EventIntegrationTestSuite struct {
	suite.Suite
	eventBus       events.EventBus
	ctx            SelectionContext
	table          SelectionTable[string]
	capturedEvents []events.Event
}

// SetupTest runs before EACH test function
func (s *EventIntegrationTestSuite) SetupTest() {
	// Create event bus for testing
	s.eventBus = events.NewBus()
	
	// Create context with test roller
	testRoller := NewTestRoller([]int{50, 25, 75}) // Predictable rolls
	s.ctx = NewSelectionContextWithRoller(testRoller)
	
	// Create table with events enabled
	config := BasicTableConfig{
		ID:       "test_event_table",
		EventBus: s.eventBus,
		Configuration: TableConfiguration{
			EnableEvents:    true,
			EnableDebugging: true,
		},
	}
	s.table = NewBasicTable[string](config)
	
	// Reset captured events
	s.capturedEvents = make([]events.Event, 0)
	
	// Subscribe to all selectables events
	s.subscribeToEvents()
}

// SetupSubTest runs before EACH s.Run()
func (s *EventIntegrationTestSuite) SetupSubTest() {
	// Reset table and events for each subtest
	config := BasicTableConfig{
		ID:       "test_event_table",
		EventBus: s.eventBus,
		Configuration: TableConfiguration{
			EnableEvents:    true,
			EnableDebugging: true,
		},
	}
	s.table = NewBasicTable[string](config)
	s.capturedEvents = make([]events.Event, 0)
}

func TestEventIntegrationSuite(t *testing.T) {
	suite.Run(t, new(EventIntegrationTestSuite))
}

func (s *EventIntegrationTestSuite) subscribeToEvents() {
	// Subscribe to table creation events
	s.eventBus.SubscribeFunc(EventSelectionTableCreated, 0, s.captureEvent)
	
	// Subscribe to item events
	s.eventBus.SubscribeFunc(EventItemAdded, 0, s.captureEvent)
	s.eventBus.SubscribeFunc(EventItemRemoved, 0, s.captureEvent)
	s.eventBus.SubscribeFunc(EventWeightChanged, 0, s.captureEvent)
	
	// Subscribe to selection events
	s.eventBus.SubscribeFunc(EventSelectionStarted, 0, s.captureEvent)
	s.eventBus.SubscribeFunc(EventSelectionCompleted, 0, s.captureEvent)
	s.eventBus.SubscribeFunc(EventSelectionFailed, 0, s.captureEvent)
	
	// Subscribe to context events
	s.eventBus.SubscribeFunc(EventContextModified, 0, s.captureEvent)
}

func (s *EventIntegrationTestSuite) captureEvent(ctx context.Context, event events.Event) error {
	s.capturedEvents = append(s.capturedEvents, event)
	return nil
}

func (s *EventIntegrationTestSuite) getEventsByType(eventType string) []events.Event {
	var filtered []events.Event
	for _, event := range s.capturedEvents {
		if event.Type() == eventType {
			filtered = append(filtered, event)
		}
	}
	return filtered
}

func (s *EventIntegrationTestSuite) TestTableCreationEvents() {
	s.Run("publishes table creation event", func() {
		// Table creation happens in SetupTest/SetupSubTest
		creationEvents := s.getEventsByType(EventSelectionTableCreated)
		
		s.Assert().Len(creationEvents, 1, "Should have exactly one table creation event")
		
		event := creationEvents[0]
		s.Assert().Equal(EventSelectionTableCreated, event.Type())
		
		// Verify event context contains table information
		tableID, exists := event.Context().Get("table_id")
		s.Assert().True(exists)
		s.Assert().Equal("test_event_table", tableID)
		
		tableType, exists := event.Context().Get("table_type")
		s.Assert().True(exists)
		s.Assert().Equal("basic", tableType)
		
		operation, exists := event.Context().Get("operation")
		s.Assert().True(exists)
		s.Assert().Equal("created", operation)
	})
}

func (s *EventIntegrationTestSuite) TestItemManagementEvents() {
	s.Run("publishes item added events", func() {
		s.table.Add("sword", 10)
		s.table.Add("shield", 15)
		
		itemEvents := s.getEventsByType(EventItemAdded)
		s.Assert().Len(itemEvents, 2, "Should have two item added events")
		
		// Check first event (sword)
		event1 := itemEvents[0]
		tableID, _ := event1.Context().Get("table_id")
		s.Assert().Equal("test_event_table", tableID)
		tableType, _ := event1.Context().Get("table_type")
		s.Assert().Equal("basic", tableType)
		operation, _ := event1.Context().Get("operation")
		s.Assert().Equal("added", operation)
		item, _ := event1.Context().Get("item")
		s.Assert().Equal("sword", item)
		weight, _ := event1.Context().Get("weight")
		s.Assert().Equal(10, weight)
		tableSize, _ := event1.Context().Get("table_size")
		s.Assert().Equal(1, tableSize)
		
		// Check second event (shield)
		event2 := itemEvents[1]
		item2, _ := event2.Context().Get("item")
		s.Assert().Equal("shield", item2)
		weight2, _ := event2.Context().Get("weight")
		s.Assert().Equal(15, weight2)
		tableSize2, _ := event2.Context().Get("table_size")
		s.Assert().Equal(2, tableSize2)
	})
	
	s.Run("publishes weight change events for existing items", func() {
		s.table.Add("sword", 10)
		
		// Clear events from initial add
		s.capturedEvents = make([]events.Event, 0)
		
		// Update weight of existing item
		s.table.Add("sword", 20)
		
		itemEvents := s.getEventsByType(EventItemAdded)
		s.Assert().Len(itemEvents, 1, "Should have one weight change event")
		
		event := itemEvents[0]
		var_, _ := event.Context().Get("operation"); s.Assert().Equal("weight_changed", value)
		var_, _ := event.Context().Get("item"); s.Assert().Equal("sword", value)
		var_, _ := event.Context().Get("weight"); s.Assert().Equal(20, value)
		var_, _ := event.Context().Get("previous_weight"); s.Assert().Equal(10, value)
		var_, _ := event.Context().Get("table_size"); s.Assert().Equal(1, value) // Size shouldn't change
	})
}

func (s *EventIntegrationTestSuite) TestSelectionEvents() {
	s.Run("publishes successful selection events", func() {
		s.table.
			Add("common", 70).
			Add("uncommon", 25).
			Add("rare", 5)
		
		// Clear table creation events
		s.capturedEvents = make([]events.Event, 0)
		
		// Perform selection
		selected, err := s.table.Select(s.ctx)
		s.Require().NoError(err)
		
		completedEvents := s.getEventsByType(EventSelectionCompleted)
		s.Assert().Len(completedEvents, 1, "Should have one selection completed event")
		
		event := completedEvents[0]
		var_, _ := event.Context().Get("table_id"); s.Assert().Equal("test_event_table", value)
		var_, _ := event.Context().Get("operation"); s.Assert().Equal("select", value)
		var_, _ := event.Context().Get("requested_count"); s.Assert().Equal(1, value)
		var_, _ := event.Context().Get("actual_count"); s.Assert().Equal(1, value)
		var_, _ := event.Context().Get("total_weight"); s.Assert().Equal(100, value) // 70+25+5
		
		// Verify selected items
		selectedItems, exists := event.Context().Get("selected_items")
		s.Assert().True(exists)
		s.Assert().IsType([]interface{}{}, selectedItems)
		items := selectedItems.([]interface{})
		s.Assert().Len(items, 1)
		s.Assert().Equal(selected, items[0])
		
		// Verify available items
		availableItems, exists := event.Context().Get("available_items")
		s.Assert().True(exists)
		s.Assert().IsType(map[interface{}]int{}, availableItems)
		
		// Verify duration is recorded
		duration, exists := event.Context().Get("duration")
		s.Assert().True(exists)
		s.Assert().IsType(time.Duration(0), duration)
	})
	
	s.Run("publishes selection events for multiple selections", func() {
		s.table.
			Add("item1", 50).
			Add("item2", 50)
		
		// Clear table creation events
		s.capturedEvents = make([]events.Event, 0)
		
		// Perform multiple selection
		selected, err := s.table.SelectMany(s.ctx, 3)
		s.Require().NoError(err)
		
		completedEvents := s.getEventsByType(EventSelectionCompleted)
		s.Assert().Len(completedEvents, 1, "Should have one selection completed event")
		
		event := completedEvents[0]
		var_, _ := event.Context().Get("operation"); s.Assert().Equal("select_many", value)
		var_, _ := event.Context().Get("requested_count"); s.Assert().Equal(3, value)
		var_, _ := event.Context().Get("actual_count"); s.Assert().Equal(3, value)
		
		// Verify selected items
		selectedItems, exists := event.Context().Get("selected_items")
		s.Assert().True(exists)
		items := selectedItems.([]interface{})
		s.Assert().Len(items, 3)
		s.Assert().Len(selected, 3)
	})
	
	s.Run("publishes selection events for unique selections", func() {
		s.table.
			Add("unique1", 25).
			Add("unique2", 25).
			Add("unique3", 25).
			Add("unique4", 25)
		
		// Clear table creation events
		s.capturedEvents = make([]events.Event, 0)
		
		// Perform unique selection
		selected, err := s.table.SelectUnique(s.ctx, 2)
		s.Require().NoError(err)
		
		completedEvents := s.getEventsByType(EventSelectionCompleted)
		s.Assert().Len(completedEvents, 1, "Should have one selection completed event")
		
		event := completedEvents[0]
		var_, _ := event.Context().Get("operation"); s.Assert().Equal("select_unique", value)
		var_, _ := event.Context().Get("requested_count"); s.Assert().Equal(2, value)
		var_, _ := event.Context().Get("actual_count"); s.Assert().Equal(2, value)
		
		// Verify selected items are unique
		selectedItems, exists := event.Context().Get("selected_items")
		s.Assert().True(exists)
		items := selectedItems.([]interface{})
		s.Assert().Len(items, 2)
		s.Assert().NotEqual(items[0], items[1], "Selected items should be unique")
		s.Assert().Len(selected, 2)
	})
}

func (s *EventIntegrationTestSuite) TestSelectionFailureEvents() {
	s.Run("publishes failure events for empty table", func() {
		// Don't add any items to table
		
		// Clear table creation events
		s.capturedEvents = make([]events.Event, 0)
		
		// Attempt selection on empty table
		_, err := s.table.Select(s.ctx)
		s.Assert().Error(err)
		
		failedEvents := s.getEventsByType(EventSelectionFailed)
		s.Assert().Len(failedEvents, 1, "Should have one selection failed event")
		
		event := failedEvents[0]
		var_, _ := event.Context().Get("table_id"); s.Assert().Equal("test_event_table", value)
		var_, _ := event.Context().Get("operation"); s.Assert().Equal("select", value)
		
		errorMsg, exists := event.Context().Get("error")
		s.Assert().True(exists)
		s.Assert().Contains(errorMsg.(string), "empty table", "Error should mention empty table")
		
		// Duration should still be recorded
		duration, exists := event.Context().Get("duration")
		s.Assert().True(exists)
		s.Assert().IsType(time.Duration(0), duration)
	})
	
	s.Run("publishes failure events for invalid count", func() {
		s.table.Add("item", 10)
		
		// Clear events
		s.capturedEvents = make([]events.Event, 0)
		
		// Attempt selection with invalid count
		_, err := s.table.SelectMany(s.ctx, 0)
		s.Assert().Error(err)
		
		failedEvents := s.getEventsByType(EventSelectionFailed)
		s.Assert().Len(failedEvents, 1, "Should have one selection failed event")
		
		event := failedEvents[0]
		var_, _ := event.Context().Get("operation"); s.Assert().Equal("select_many", value)
		
		errorMsg, exists := event.Context().Get("error")
		s.Assert().True(exists)
		s.Assert().Contains(errorMsg.(string), "count", "Error should mention count")
	})
	
	s.Run("publishes failure events for insufficient unique items", func() {
		s.table.Add("only_item", 10)
		
		// Clear events
		s.capturedEvents = make([]events.Event, 0)
		
		// Attempt to select more unique items than available
		_, err := s.table.SelectUnique(s.ctx, 5)
		s.Assert().Error(err)
		
		failedEvents := s.getEventsByType(EventSelectionFailed)
		s.Assert().Len(failedEvents, 1, "Should have one selection failed event")
		
		event := failedEvents[0]
		var_, _ := event.Context().Get("operation"); s.Assert().Equal("select_unique", value)
		
		errorMsg, exists := event.Context().Get("error")
		s.Assert().True(exists)
		s.Assert().Contains(errorMsg.(string), "insufficient", "Error should mention insufficient items")
	})
	
	s.Run("publishes failure events for missing context", func() {
		s.table.Add("item", 10)
		
		// Clear events
		s.capturedEvents = make([]events.Event, 0)
		
		// Attempt selection without context
		_, err := s.table.Select(nil)
		s.Assert().Error(err)
		
		failedEvents := s.getEventsByType(EventSelectionFailed)
		s.Assert().Len(failedEvents, 1, "Should have one selection failed event")
		
		event := failedEvents[0]
		var_, _ := event.Context().Get("operation"); s.Assert().Equal("select", value)
		
		errorMsg, exists := event.Context().Get("error")
		s.Assert().True(exists)
		s.Assert().Contains(errorMsg.(string), "context", "Error should mention context")
	})
}

func (s *EventIntegrationTestSuite) TestEventDataIntegrity() {
	s.Run("includes context information in selection events", func() {
		s.table.Add("item", 10)
		
		// Create context with various values
		testCtx := s.ctx.
			Set("player_level", 5).
			Set("environment", "forest").
			Set("is_night", true)
		
		// Clear events
		s.capturedEvents = make([]events.Event, 0)
		
		// Perform selection
		_, err := s.table.Select(testCtx)
		s.Require().NoError(err)
		
		completedEvents := s.getEventsByType(EventSelectionCompleted)
		s.Require().Len(completedEvents, 1)
		
		event := completedEvents[0]
		
		// Verify context is included in event
		contextData, exists := event.Context().Get("context")
		s.Assert().True(exists)
		s.Assert().IsType(map[string]interface{}{}, contextData)
		
		ctxMap := contextData.(map[string]interface{})
		s.Assert().Equal(5, ctxMap["player_level"])
		s.Assert().Equal("forest", ctxMap["environment"])
		s.Assert().Equal(true, ctxMap["is_night"])
	})
	
	s.Run("includes roll results in selection events", func() {
		s.table.
			Add("item1", 50).
			Add("item2", 50)
		
		// Clear events
		s.capturedEvents = make([]events.Event, 0)
		
		// Perform selection
		_, err := s.table.Select(s.ctx)
		s.Require().NoError(err)
		
		completedEvents := s.getEventsByType(EventSelectionCompleted)
		s.Require().Len(completedEvents, 1)
		
		event := completedEvents[0]
		
		// Verify roll results are included
		rollResults, exists := event.Context().Get("roll_results")
		s.Assert().True(exists)
		s.Assert().IsType([]int{}, rollResults)
		
		rolls := rollResults.([]int)
		s.Assert().NotEmpty(rolls, "Should have at least one roll result")
	})
	
	s.Run("includes timing information in events", func() {
		s.table.Add("item", 10)
		
		// Clear events
		s.capturedEvents = make([]events.Event, 0)
		
		startTime := time.Now()
		_, err := s.table.Select(s.ctx)
		endTime := time.Now()
		s.Require().NoError(err)
		
		completedEvents := s.getEventsByType(EventSelectionCompleted)
		s.Require().Len(completedEvents, 1)
		
		event := completedEvents[0]
		
		// Verify duration is reasonable
		duration, exists := event.Context().Get("duration")
		s.Assert().True(exists)
		s.Assert().IsType(time.Duration(0), duration)
		
		eventDuration := duration.(time.Duration)
		s.Assert().LessOrEqual(eventDuration, endTime.Sub(startTime), "Event duration should be reasonable")
		s.Assert().GreaterOrEqual(eventDuration, time.Duration(0), "Duration should be non-negative")
	})
}

func (s *EventIntegrationTestSuite) TestEventPublisherFunctionality() {
	s.Run("handles nil event bus gracefully", func() {
		// Create table without event bus
		config := BasicTableConfig{
			ID: "no_events_table",
			Configuration: TableConfiguration{
				EnableEvents: true, // Even with events enabled, no bus means no events
			},
		}
		
		noEventsTable := NewBasicTable[string](config)
		noEventsTable.Add("item", 10)
		
		// This should not panic or error
		_, err := noEventsTable.Select(s.ctx)
		s.Assert().NoError(err, "Selection should work even without event bus")
	})
	
	s.Run("respects event configuration", func() {
		// Create table with events disabled
		config := BasicTableConfig{
			ID:       "disabled_events_table",
			EventBus: s.eventBus,
			Configuration: TableConfiguration{
				EnableEvents: false, // Events disabled
			},
		}
		
		disabledTable := NewBasicTable[string](config)
		
		// Clear existing events
		s.capturedEvents = make([]events.Event, 0)
		
		disabledTable.Add("item", 10)
		_, err := disabledTable.Select(s.ctx)
		s.Require().NoError(err)
		
		// Should have no events because they're disabled
		s.Assert().Empty(s.capturedEvents, "No events should be published when disabled")
	})
}

func (s *EventIntegrationTestSuite) TestEventSourceIdentity() {
	s.Run("events have correct source entity", func() {
		s.table.Add("item", 10)
		
		// Clear events
		s.capturedEvents = make([]events.Event, 0)
		
		_, err := s.table.Select(s.ctx)
		s.Require().NoError(err)
		
		completedEvents := s.getEventsByType(EventSelectionCompleted)
		s.Require().Len(completedEvents, 1)
		
		event := completedEvents[0]
		source := event.Source()
		
		s.Assert().NotNil(source, "Event should have a source")
		s.Assert().Equal("test_event_table", source.GetID())
		s.Assert().Equal("basic", source.GetType())
	})
}